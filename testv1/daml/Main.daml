{-# LANGUAGE ApplicativeDo #-}

module Main where

import Daml.Script

import DA.Foldable (forA_)

template Point
  with
    owner  : Party
    x      : Numeric 10
    y      : Numeric 10
  where
    signatory owner

template NamedPoint
  with
    owner : Party
    x     : Numeric 10
    y     : Numeric 10
    name  : Text
  where
    signatory owner

ensureParty : Text -> Script Party
ensureParty partyName = do
  knownParties <- listKnownParties

  case find (\pd -> pd.displayName == Some partyName) knownParties of
    Some p -> pure p.party
    None -> do
      alice <- allocatePartyWithHint partyName (PartyIdHint partyName)
      aliceId <- validateUserId partyName
      createUser (User aliceId (Some alice)) [CanActAs alice]
      pure alice

batchCommand : Int -> [Commands ()] -> [Commands ()]
batchCommand n [] = []
batchCommand n (xs) = 
  let (batch,rest) = splitAt n xs
  in forA_ batch identity :: batchCommand n rest

batchSize = 100
contractGroups = 1000

test : Script ()
test = do
  alice <- ensureParty "alice"

  debugRaw $ "Generating commands to create " <> (show contractGroups) <> " contract group(s)."
  batches <- batchCommand batchSize <$> forA [0..contractGroups-1] (\ii -> do
    let 
     commands = do 
      createCmd Point with
        owner = alice
        x = 3.0
        y = 4.0
      createCmd Point with
        owner = alice
        x = 5.0
        y = 12.0
      createCmd NamedPoint with
        owner = alice
        x = 0.0
        y = 0.0
        name = "Origin"
      pure ()
    pure commands)

  -- TODO: Investigate why the number of batches is batchSize/contractGroups rather than (batchSize/contractGroups)*3
  debugRaw $ "Submitting " <> (show (length batches)) <> " batches with " <> (show batchSize) <> " commands each."
  forA_ batches (\batch -> do
    debugRaw "Submitting batch..."
    submit alice batch)

  pure ()

